#!/usr/bin/env python3
"""
Build CV PDF from regenerated LaTeX file using pdflatex.
Runs pdflatex twice to ensure proper page references.
"""

import sys
import subprocess
import shutil
from pathlib import Path
import click
from loguru import logger
import time

# Configure logger
logger.remove()
logger.add(sys.stderr, level="INFO")


def check_pdflatex():
    """Check if pdflatex is available."""
    if shutil.which('pdflatex') is None:
        logger.error("pdflatex not found. Please install a LaTeX distribution.")
        logger.info("  - On Ubuntu/Debian: sudo apt-get install texlive-full")
        logger.info("  - On macOS: brew install --cask mactex")
        logger.info("  - On Windows: Install MiKTeX or TeX Live")
        return False
    return True


def run_pdflatex(tex_file: Path, output_dir: Path, run_number: int):
    """Run pdflatex on the given file."""
    logger.info(f"Running pdflatex (pass {run_number})...")
    
    cmd = [
        'pdflatex',
        '-interaction=nonstopmode',
        '-output-directory', str(output_dir),
        str(tex_file)
    ]
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=60  # 60 second timeout
        )
        
        if result.returncode != 0:
            logger.error(f"pdflatex failed with return code {result.returncode}")
            # Log last 20 lines of output for debugging
            error_lines = result.stdout.split('\n')[-20:]
            for line in error_lines:
                if line.strip():
                    logger.debug(line)
            return False
            
        # Check for important warnings
        if "Warning" in result.stdout:
            warning_count = result.stdout.count("Warning")
            logger.warning(f"pdflatex completed with {warning_count} warnings")
            
        return True
        
    except subprocess.TimeoutExpired:
        logger.error("pdflatex timed out after 60 seconds")
        return False
    except Exception as e:
        logger.error(f"Error running pdflatex: {e}")
        return False


def clean_auxiliary_files(output_dir: Path, base_name: str):
    """Clean auxiliary files generated by LaTeX."""
    extensions = ['.aux', '.log', '.out', '.toc', '.lof', '.lot', '.bbl', '.blg']
    
    for ext in extensions:
        file_path = output_dir / f"{base_name}{ext}"
        if file_path.exists():
            file_path.unlink()
            

@click.command()
@click.option('--input', '-i',
              default='output/ClassicFullCV-Dutykh.tex',
              help='Input LaTeX file to compile')
@click.option('--output-dir', '-o',
              default='output',
              help='Output directory for PDF and auxiliary files')
@click.option('--clean/--no-clean',
              default=True,
              help='Clean auxiliary files after compilation')
@click.option('--regenerate/--no-regenerate',
              default=False,
              help='Regenerate LaTeX from YAML before building')
def main(input: str, output_dir: str, clean: bool, regenerate: bool):
    """Build CV PDF from LaTeX file using pdflatex."""
    
    # Check if pdflatex is available
    if not check_pdflatex():
        sys.exit(1)
    
    # Regenerate LaTeX if requested
    if regenerate:
        logger.info("Regenerating LaTeX from YAML...")
        result = subprocess.run([sys.executable, 'regenerate_cv.py'], capture_output=True)
        if result.returncode != 0:
            logger.error("Failed to regenerate LaTeX")
            sys.exit(1)
        logger.info("LaTeX regeneration complete")
    
    # Check input file
    input_path = Path(input)
    if not input_path.exists():
        logger.error(f"Input file not found: {input}")
        logger.info("Did you run 'python regenerate_cv.py' first?")
        sys.exit(1)
    
    # Create output directory
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Get base name for output files
    base_name = input_path.stem
    
    logger.info(f"Building PDF from: {input}")
    logger.info(f"Output directory: {output_dir}")
    
    # Measure build time
    start_time = time.time()
    
    # Run pdflatex twice
    success = True
    for i in range(1, 3):
        if not run_pdflatex(input_path, output_path, i):
            success = False
            break
        
        # Small delay between runs
        if i < 2:
            time.sleep(0.5)
    
    # Calculate build time
    build_time = time.time() - start_time
    
    if success:
        pdf_path = output_path / f"{base_name}.pdf"
        if pdf_path.exists():
            pdf_size = pdf_path.stat().st_size / 1024  # Size in KB
            logger.success(f"âœ“ PDF generated successfully: {pdf_path}")
            logger.info(f"  PDF size: {pdf_size:.1f} KB")
            logger.info(f"  Build time: {build_time:.1f} seconds")
            
            # Clean auxiliary files if requested
            if clean:
                logger.info("Cleaning auxiliary files...")
                clean_auxiliary_files(output_path, base_name)
        else:
            logger.error("PDF file not generated despite successful compilation")
            success = False
    
    if not success:
        logger.error("Build failed. Check the log file for details:")
        log_path = output_path / f"{base_name}.log"
        if log_path.exists():
            logger.error(f"  {log_path}")
        sys.exit(1)


if __name__ == '__main__':
    main()